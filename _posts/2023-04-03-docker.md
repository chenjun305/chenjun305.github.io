---
layout: post
title: docker原理
date: 2023-04-03 17:00:00
description: 
tags: docker
categories: programming
---

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/docker-vs-vm.png" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>
<div class="caption">
  docker vs vm
</div>

## 通过Linux Namespace机制实现容器的隔离
Namespace机制是Linux内核提供的一种隔离资源的机制。Docker使用Namespace实现容器之间的隔离:
- PID namespace:隔离进程ID,使得容器内外的同一个PID实际上对应不同的进程。
- IPC namespace:隔离系统间消息队列、信号量和共享内存对象,使得这些资源在容器之间隔离。
- Network namespace:隔离网络设备、IP地址和端口,每个容器都有自己的网络接口、IP地址和端口。
- UTS namespace:隔离主机名和域名,每个容器可以有自己的主机名。
- Mount namespace:隔离挂载点,每个容器都有自己的根文件系统,对容器来说,主机的文件系统就是其文件系统的一个目录。
- User namespace:隔离用户和组ID,使得容器内外用户和组ID相同的用户实际上是不同的用户。

Docker项目帮助用户启动的还是原来的的应用进程，只不过在创建这些进程时，Docker为它们加上了各种各样的Namespace参数。以PID namespace为例,在Linux系统中创建进程的系统调用是`clone()`,它允许在创建新进程时指定Namespace类型(`CLONE_NEWPID`), 这时，新创建的进程将会“看到”一个全新的进程空间。在这个空间里，它的PID是1.在宿主机的真实进程空间里，这个进程的PID还是真实的数值，比如100.

```
int pid = clone(main_func, stack_size, CLONE_NEWPID | SIGCHLD, NULL);
```
可见，容器其实是一种特殊的进程而已。

与传统虚拟机相比,容器的优势在于:
- 容器化的应用依然是宿主机上的普通进程，不存在因为虚拟化而产生的性能损耗。
- 不需要单独的客户操作系统，容器内的应用直接运行于宿主机的内核,从而更轻量级。

不过，有利就有弊，基于Linux Namespace的隔离机制相比于虚拟化技术也有很多不足之处。
- 隔离的不彻底，容器内外还是共享很多系统资源,比如主机的内核、时间源等。这给安全性带来一定风险。
- 如果要在Windows宿主机上运行Linux容器，或在低版本的Linux主机上运行高版本的Linux容器，都是行不通的。
- Linux内核中，有很多资源是不能被Namespace化的，最典型的例子就是：时间

所以，在生产环境中，没人敢把在物理机上运行的Linux容器直接暴露在公网上。

## 通过Linux Cgroups实现容器资源限制
Linux Cgroups (Linux Control groups)最主要的作用就是限制一个进程组能够使用的资源上限，包括CPU，内存，磁盘，网络带宽，等等。
此外，Cgroups还能对进程进行优先级设置，审计，及将将进程挂起和恢复等操作。
在Linux中，Cgroups向用户暴露出来的操作接口是文件系统，在/sys/fs/cgroup路径下。
可以用`mount`指令将其显示：
```
$ mount -t cgroup
cpuset on /sys/fs/cgroup/cpuset
cpu on /sys/fs/cgroup/cpu
cpuacct  on /sys/fs/cgroup/cpuacct
blkio on /sys/fs/cgroup/blkio
memory on /sys/fs/cgroup/memory
```
Cgroups的每一项子系统都有其独有的资源限制能力，比如

- cpu， 为进程设置cpu使用配额；
- cpuset， 主要用于设置CPU的亲和性，可以限制cgroup中的进程只能在指定的CPU上运行，或者不能在指定的CPU上运行，同时cpuset还能设置内存的亲和性;
- cpuacct, 包含当前cgroup所使用的CPU的统计信息;
- blkio， 为块设备设定I/O限制，一般用于磁盘等设备；
- memory， 为进程设定内存使用限制；

使用方法为在需要限制资源的子系统路径下创建“控制组”文件夹，在该文件夹下再将限制信息进行修改。最后将需要限制的进程ID写入文件夹下的tasks文件。
例如，以下docker run命令：
```
$ docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash
```
启动这个容器后，查看相关限制文件：
```
$ cat /sys/fs/cgroup/cpu/docker/xxxxx/cpu.cfs_period_us
100000
$ cat /sys/fs/cgroup/cpu/docker/xxxxx/cpu.quota_us
20000
```
这就意味着这个docker容器只能使用20%的cpu。


## docker command

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/docker-command.webp" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>
<div class="caption">
  docker command
</div>
